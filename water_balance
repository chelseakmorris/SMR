# Soil Moisture Routing Model
# Water Balance Program
# Chelsea K Morris
# last updated 28 March 2013

# Distributed, physically-based model predicts soil moisture distribtuion using 
# a simple water balance approach.
# Input parameters include day of year, year, depth of precipitation, snowmelt,
# potential evaporation, soils data, and elevation.

setwd("~/Dropbox/Model")
weather<-read.csv("weather.csv", header=TRUE, sep=",")
P<-weather$PRCP  # precipitation (cm)
Melt<-rep(0,length(P)) # snowmelt (cm) from another function. Currently set to zero.
PET<- weather$PET  # potential evapotranspiration (cm). Currenly using monthly averages for Elmira, NY.
                   # Eventually, this parameter will be a spatially and seasonally variable coeffecient.
deltaP<- P-PET  # the difference between precipitation and PET (cm)

#  Add the daily precipitation.
#  Determine the amount of water lost to evapotranspiration with 
#  Thornthwaite-Mather equation. The acutal ET is based on soil moisture content,
#  ET coefficient, and potential ET. Taken from Jo Archibald. Slightly different
#  from Frankenberger model. Right now this doesn't account for snow melt.

StorageAmt <- vector(length=length(P))  #Soil Water
StorageAmt[1]<-0
for(i in 2:length(P)){
  if (deltaP[i] > 0) {
    StorageAmt[i]<- StorageAmt[i] + deltaP[i] + Melt[i]
  } else if(deltaP[i] <= 0){     		# Condition drying
    StorageAmt[i] <- StorageAmt[i]*exp(deltaP[i]/AWC)
  }
}
#  Distribute precipitation input among soil layers.

      ###To be determined.

#  Calculate portion of the soil column that is saturated, at field capacity,
#  or below field capacity and assign an effective hydraulic conductivity that
#  will determine lateral flow.

SoilDepth <- 10 # depth (cm) to restrictive layer. Currently a test value is used.
fc <- 0.4  #field capacity as a percent of. Temporary value.
fcAmt <- SoilDepth*fc  #amount of water when entire cell is at field capacity (cm)
wp <- 0.05  #wilting point percent. Temporary value.
wpAmt <- SoilDepth*wp  #amount of water when entire cell is at wilting point (cm)
sat <- 0.5 #saturation point; equal to porosity. Temporary value.
satAmt <- SoilDepth*sat #amount of water when entire cell is saturated (cm)
AWC <- satAmt-wpAmt  #available water capacity (cm)

Excess <- rep(0,length(P))  #Amount of water available to flow out of the cell (cm).
Runoff <- rep(0,length(P))	# Runoff (cm)

for(i in 2:length(P)){
  if (StorageAmt[i] <= fcAmt) {
    Excess[i] <- 0   #Cell has uniform moisture gradient, no saturated portion
  } 
  else if (StorageAmt[i] > satAmt){
    Runoff[i] <- (StorageAmt[i]-satAmt) #Cell has some portion in above saturation 
                                        # that will become runoff.
   
    Excess[i] <- (satAmt-fcAmt)         #The rest above field capacity will move laterally 
  }                                     # and/or to GW storage.
  else if (StorageAmt[i] > fcAmt)  {
    Excess[i] <- (StorageAmt[i]-fcAmt)  #Cell has some sat. portion that move laterally 
  }                                     # and/or enter the GW storage.
}

#  Calculate lateral flow from each cell based on Darcy's Law. Gradient equals  
#  land slope. Inputs include slope, saturated hydraulic conductivity, and depth
#  of saturated layer.

slope <- 0.05  # slope generated by DEM (m/m). 
aspect <- pi/2 # flow direction (radians from north).
Ksat <- 60 # horizontal saturated hydraulic conductivity (cm/day)
width <- 100  #width of cell (cm). Currently set for 1m cell.
porosity <- 0.5
hArea <- width*SoilDepth #area of horizontal face of cell water (cm2)
Lateral <- rep(0, length(P))

for (i in 2:length(P)){
  if (Excess[i] >= (Ksat*slope*(SoilDepth*width)/hArea)/porosity) { # Condition 1: Lateral flow is at 
    Lateral[i] <- (Ksat*slope*(SoilDepth*width)/hArea)/porosity     # maximum for ks and slope.
  } 
  else if (Excess[i] < (Ksat*slope*(SoilDepth*width)/hArea)/porosity) { #Condition 2: For less than max 
    Lateral[i] <-Excess[i]                       # lateral flow, assume all 
  }                                               # of excess water moves laterally.
  else if (Excess[i] <= 0) {  #Condition 3: No excess water
    Lateral[i] <- 0
  }
  Excess[i] <- Excess[i]-Lateral[i]
}
#   Portion the lateral flow calculated above to adjacent cells. Need to figure
#   out how we will model diversions and tile drains (as necessary).
outflow <- data.frame(E=rep(0, length(P)), NE=rep(0, length(P)), N=rep(0, length(P)),
                      NW=rep(0, length(P)), W=rep(0, length(P)), SW=rep(0, length(P)), 
                      S=rep(0, length(P)), SE=rep(0, length(P)))

for (i in 2:length(P)) {
  if ((aspect >= 0) && (aspect <= pi/8)) {
    outflow([i] <- Lateral[i]
  }else if ((aspect > pi/8) && (aspect <= 3*pi/8)) {
    outflow$NE[i] <- Lateral[i]
  }else if ((aspect > 3*pi/8) && (aspect <= 5*pi/8)) {
    outflow$N[i] <- Lateral[i]
  }else if ((aspect > 5*pi/8) && (aspect <= 7*pi/8)) {
    outflow$NW[i] <- Lateral[i]
  }else if ((aspect > 7*pi/8) && (aspect <= 9*pi/8)) {
    outflow$W[i] <- Lateral[i]
  }else if ((aspect > 9*pi/8) && (aspect <= 11*pi/8)) {
    outflow$SW[i] <- Lateral[i]
  }else if ((aspect > 11*pi/8) && (aspect <= 13*pi/8)) {
    outflow$S[i] <- Lateral[i]
  }else if ((aspect > 13*pi/8) && (aspect <= 15*pi/8)) {
    outflow$SE[i] <- Lateral[i]
  }else if ((aspect > 15*pi/8) && (aspect <= 2*pi)) {
    outflow$E[i] <- Lateral[i]
}

#   Calculate the amount of water lost to percolation through the restricting layer. 
#   Currently, because the lateral flow hasn't been subtracted out, all excess flow, 
#   up to K, is heading to GW instead of a portion moving laterally.

GW <- vector(length=length(P))  # Groundwater storage
GW[1] <- 10  # Initial storage observed before our model run
perc<-rep(0, length(P))
KsatRestrictive <- 0.3 #vertical saturated hydraulic conductivity (cm/day). Eventually will be from input file.

for(i in 2:length(P)) {
  if (Excess[i] >= (KsatRestrictive)) {
    perc[i] <- KsatRestrictive
  } else if (Excess[i] < KsatRestrictive) {
    perc[i] <- Excess[i]
  }else if (Excess[i] <= 0) {
    perc[i] <- 0
  }
  Excess[i] <- Excess[i]-perc[i]
  GW[i] <- GW[i-1] + perc[i]
}

#   Balance the lateral flows, percolation, runoff in the cell of interest.
#   Calculate contribution to baseflow and streamflow. This does not concern the
#   water balance, so consider moving this to another function.
  
  # inflow is currently a blank dataframe, but eventually should reference the data frames
  # generated by surrounding cells.
inflow<- data.frame(E=rep(0, length(P)), NE=rep(0, length(P)), N=rep(0, length(P)),
                    NW=rep(0, length(P)), W=rep(0, length(P)), SW=rep(0, length(P)), 
                    S=rep(0, length(P)), SE=rep(0, length(P)))
  
for(i in 2:length(P)){
  StorageAmt[i] <- StorageAmt[i]-Lateral[i]-perc[i]  #  Subtract the lateral flow leaving to downslope cells and the percolation to GW.
 
  Inflow[i] <- rowSums(inflow)
  StorageAmt[i] <- StorageAmt[i]+Inflow[i]  #  Add the lateral flow from upslope cells. To be determined.
  
  StorageAmt[i]<-StorageAmt[i]-Runoff[i]  #  Subtract runoff generated from each cell.
  
  baseflow[i]<- RecessionCoeff*GW[i] #   Generate Hydrograph Ouputs
  Streamflow[i]<-Runoff[i] + baseflow[i]
}
