# Soil Moisture Routing Model
# Water Balance Program
# Chelsea K Morris
# last updated 9 April 2013

# Distributed, physically-based model predicts soil moisture distribtuion using 
# a simple water balance approach.
# Input parameters include day of year, year, depth of precipitation, snowmelt,
# potential evaporation, soils data, and elevation.

setwd("~/Dropbox/Model")


# Global Conditions

	n <- 10 # number of rows in gridded watershed
	m <- 10 # number of columns in gridded watershed
	grid <- matrix(0,nrow=n, ncol=m)

	width <- 1000  #width of cell (cm). Currently set for 1km2 cell.
	weather<-read.csv("weather.csv", header=TRUE, sep=",")
  GW <- vector(length=length(weather$PRCP))  # Groundwater storage
  GW[1] <- 10  # Initial storage observed before our model run	
  streamflow <- vector(length=length(weather$PRCP))
  inflow<-matrix(0, nrow=n, ncol=m)
  outflow<-matrix(0, nrow=n, ncol=m)
  
  StorageAmt <- matrix(1, nrow=n, ncol=m)  #Soil Water
	SoilDepth <- matrix(10, nrow=n, ncol=m) # depth (cm) to restrictive layer. Currently a test value is used.
	fc <- matrix(0.4, nrow=n, ncol=m)  #field capacity as a percent of. Temporary value.
	fcAmt <- SoilDepth*fc  #amount of water when entire cell is at field capacity (cm)
	wp <- matrix(0.05, nrow=n, ncol=m)  #wilting point percent. Temporary value.
	wpAmt <- SoilDepth*wp  #amount of water when entire cell is at wilting point (cm)
	sat <- matrix(0.5, nrow=n, ncol=m) #saturation point; equal to porosity. Temporary value.
	satAmt <- SoilDepth*sat #amount of water when entire cell is saturated (cm)
	AWC <- satAmt-wpAmt  #available water capacity (cm)
	
	slope <- matrix(0.05, nrow=n, ncol=m)  # slope generated by DEM (m/m). 
	aspect <- as.matrix(read.csv("aspect.csv", header=FALSE, sep=",")) # flow direction (radians from east).	
	a <- 1 # row number for watershed outlet
	b <- 10 # column number for watershed outlet
  	Ksat <- matrix(60, nrow=n, ncol=m) # horizontal saturated hydraulic conductivity (cm/day)
	porosity <- matrix(0.5, nrow=n, ncol=m)
	hArea <- width*SoilDepth #area of horizontal face of cell water (cm2)
	KsatRestrictive <- matrix(0.3, nrow=n, ncol=m) #vertical saturated hydraulic conductivity (cm/day).

  test.stor<-vector()

# Set daily weather conditions & step through water balance

for (date in 1:length(weather$PRCP)){
	P<-weather$PRCP[date]  # precipitation (cm)
	Melt<-weather$Melt[date] # snowmelt (cm) from another function. Currently set to zero.
  PET<- weather$PET[date] # potential evapotranspiration (cm). Currenly using monthly averages for 
                          # Elmira, NY. Eventually, this parameter will be a spatially and seasonally 
                          # variable coeffecient.

# Add the daily precipitation.
# Determine the amount of water lost to evapotranspiration with 
# Thornthwaite-Mather equation. The acutal ET is based on soil moisture content,
# ET coefficient, and potential ET. Taken from Jo Archibald. Slightly different
# from Frankenberger model.

#WaterBalance <- function(date){
deltaP<- P-PET  # the difference between precipitation and PET (cm)

for (i in 1:length(grid)){
	if (deltaP > 0) {
			StorageAmt[i]<- StorageAmt[i] + deltaP + Melt
  		} else if(deltaP <= 0){   			# Condition drying
    			StorageAmt[i] <- StorageAmt[i]*exp(deltaP/AWC[i])
		}
}

# Distribute precipitation input among soil layers.

      ###To be determined.

# Calculate portion of the soil column that is saturated, at field capacity,
# or below field capacity and assign an effective hydraulic conductivity that
# will determine lateral flow.


Excess <- grid  #Amount of water available to flow out of the cell (cm).
Runoff <- grid	# Runoff (cm). Resets to zero

for (i in 1:length(grid)){
  if (StorageAmt[i] <= fcAmt[i]) {
   	Excess[i] <- 0   #Cell has uniform moisture gradient, no saturated portion
  } 
  else if (StorageAmt[i] > satAmt[i]){
    Runoff[i] <- (StorageAmt[i]-satAmt[i]) #Cell has some portion in above saturation 
                                        # that will become runoff.
   
    Excess[i] <- (satAmt[i]-fcAmt[i])         #The rest above field capacity will move laterally 
  }                                     # and/or to GW storage.
  else if (StorageAmt[i] > fcAmt[i])  {
    Excess[i] <- (StorageAmt[i]-fcAmt[i])  #Cell has some sat. portion that move laterally 
  }                                     # and/or enter the GW storage.
}

#  Calculate lateral flow from each cell based on Darcy's Law. Gradient equals  
#  land slope. Inputs include slope, saturated hydraulic conductivity, and depth
#  of saturated layer.

Lateral <- grid  # lateral flow resets to zero

for (i in 1:length(grid)){
  if (Excess[i] >= (Ksat[i]*slope[i]*(SoilDepth[i]*width)/hArea[i])/porosity[i]) { # Condition 1: Lateral flow is at 
    Lateral[i] <- (Ksat[i]*slope[i]*(SoilDepth[i]*width)/hArea[i])/porosity[i]     # maximum for ks and slope.
  } 
  else if (Excess[i] < (Ksat[i]*slope[i]*(SoilDepth[i]*width)/hArea[i])/porosity[i]) { #Condition 2: For less than max 
    Lateral[i] <-Excess[i]                       # lateral flow, assume all 
  }                                               # of excess water moves laterally.
  else if (Excess[i] <= 0) {  #Condition 3: No excess water
    Lateral[i] <- 0
  }
  Excess[i] <- Excess[i]-Lateral[i]
}

#   Portion the lateral flow calculated above to adjacent cells. Need to figure
#   out how we will model diversions and tile drains (as necessary).

inflow<- outflow  #outflow from yesterday becomes today's inflow
outflow<-grid	  #outflow resets to zero

for (y in 1:ncol(grid)) {
	for(x in 1:nrow(grid)) {
	  if ((x==a) && (y==b)) {
      streamflow[date] <-streamflow[date]+Lateral[x,y]
	  }else {
		  if ((aspect[x, y] >= 0) && (aspect[x,y] <= pi/8)) {
		    outflow[x-1, y] <- outflow[x-1, y] + Lateral[x,y]
		  }else if ((aspect[x,y] > pi/8) && (aspect[x,y] <= 3*pi/8)) {
		    outflow[x-1, y+1] <- outflow[x-1, y+1]+ Lateral[x,y]
		  }else if ((aspect[x,y] > 3*pi/8) && (aspect[x,y] <= 5*pi/8)) {
		    outflow[x, y+1] <- outflow[x, y+1] + Lateral[x,y]
		  }else if ((aspect[x,y] > 5*pi/8) && (aspect[x,y] <= 7*pi/8)) {
		    outflow[x+1, y+1] <- outflow[x+1, y+1] + Lateral[x,y]
		  }else if ((aspect[x,y] > 7*pi/8) && (aspect[x,y] <= 9*pi/8)) {
		    outflow[x+1, y] <- outflow[x+1, y] + Lateral[x,y]
		  }else if ((aspect[x,y] > 9*pi/8) && (aspect[x,y] <= 11*pi/8)) {
		    outflow[x+1, y-1] <- outflow[x+1, y-1] + Lateral[x,y]
		  }else if ((aspect[x,y] > 11*pi/8) && (aspect[x,y] <= 13*pi/8)) {
		    outflow[x, y-1] <- outflow[x, y-1] + Lateral[x,y]
		  }else if ((aspect[x,y] > 13*pi/8) && (aspect[x,y] <= 15*pi/8)) {
		    outflow[x-1, y-1] <- outflow[x-1, y-1] + Lateral[x,y]
		  }else if ((aspect[x,y] > 15*pi/8) && (aspect[x,y] <= 2*pi)) {
		    outflow[x-1, y] <- outflow[x-1, y] + Lateral[x,y]
		  }
		} 
	}
}


#   Calculate the amount of water lost to percolation through the restricting layer. 
#   Currently, because the lateral flow hasn't been subtracted out, all excess flow, 
#   up to K, is heading to GW instead of a portion moving laterally.


perc<-matrix(0, nrow=n, ncol=m) # Percolation to groundwater storage


for(i in 1:length(grid)) {
  if (Excess[i] >= (KsatRestrictive[i])) {
    perc[i] <- KsatRestrictive[i]
  } else if (Excess[i] < KsatRestrictive[i]) {
    perc[i] <- Excess[i]
  }else if (Excess[i] <= 0) {
    perc[i] <- 0
  }
  Excess[i] <- Excess[i]-perc[i]
}
totalperc <- sum(rowSums(perc))
  GW[date+1] <- GW[date] + totalperc #Percolation is added to tomorrow's groundwater storage

#   Balance the lateral flows, percolation, runoff in the cell of interest.
for(i in 1:length(grid)){
  StorageAmt[i] <- StorageAmt[i]-Lateral[i]-perc[i]-Runoff[i]+inflow[i]  #  Subtract the lateral flow leaving to downslope cells and the percolation to GW. Subtract runoff generated from each cell. Add the lateral flow from yesterday's lateral outflow function.
}
streamflow[date] <- streamflow[date] + sum(rowSums(Runoff))

test.stor <- append(test.stor, (StorageAmt[1,1]))

} #### Ends the WaterBalance Function

